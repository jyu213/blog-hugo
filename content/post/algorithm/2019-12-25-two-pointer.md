+++
title: "题解算法之双指针法"
date: 2019-12-25T01:58:40+08:00
draft = true
tags = ["算法"]
categories = ["算法"]
description = "leetcode 算法题分析"
+++

先来看一个很简单的[题目](https://leetcode.com/problems/two-sum/)： 

> 给定一个整数 `nums` 和一个目标值 `target`，请在该数组中找出和为目标值的那两个整数，并返回他们的下标。
> 示例： 给定 `nums = [2,7,11,15], target = 9`; 
> 返回： `[0,1]` 

## 分析
解法有很多种，首先最简单的思维，暴力破解法，依次循环遍历每个元素 i, 并查找是否存在元素 `target - i`，因为只是涉及到两个未知数，所以他的算法时间复杂度为 `O(n^2)，空间复杂度为 `O(1)`。该题还存在使用 Hash 来优化等解法，不过不是这次的重点，有兴趣的同学可以自己思考一下。 

## 双指针法（Tow Pointer）
双指针的核心思想指的是，在遍历数组或对象的时候，使用两个指针（或者说是索引）甚至多个指针来达到对应操作的目的，一般应用在数组，链表，字符串等遍历操作上。

大概可以分为三类
* 同向型指针：两个指针向相同方向移动，依据速度的快慢来标记。
* 相向型指针：两个指针从相反的方向移动，直到他们相遇为止。
* 两个数组的指针：分为在两个不同的数组上，多出现在合并相关中。

上述题目我们从双指针的角度入手，如果想要两个数 a, b 之和为 `target`，我们只需要在一个有序的数组中，分别从两头开始向中间移动，如果 a, b 之和小于 `target` 的话，a + 1， 大于的话则 b - 1, 直到结果等于 `target` 或无。其时间复杂度为 O(n)。（缺图待补充）

```javascript
const twoSum = function(nums, target) {
	let m = 0, n = 0
	nums = nums.sort((a, b) => a - b) // 排序的示意
	for (let i = 0, j = nums.length - 1; i < j;) {
		const sum = nums[i] + nums[y]
		if (sum < target) {
			i++
		} else if (sum > target) {
			y--
		} else if (sum === target) {
			m = i
			n = y
		}
	}
	// 省略实际获取排序前的坐标内容
}
```

不过针对上面的题目没有讲到数组是有序的，所以加上给数据排序需要花费的时间复杂度是 nO(logn)，并没有 Hash 的方法有优势。


这里，我们得到适合双指针的条件是，有序的数列，而更重要的是两个指针移动的条件（比如步长或方向）不同。这个其实在面试题中还是比较容易出现的。

> 扩展题：上述题目中，是否存在三个元素之和等于 `target` 的？ 

### 应用
* 链表判断是否闭环，
* 数组判断是否有重复元素 （其中一个指向当前不重复的最后一个元素，另一个依次扫描，遇到不重复的更新第一个指针，重复的则删除
* 链表取倒数 k 的值，`所在节点 = len - k + 1`, 所以先设置一个移动 k + 1, 再两个指针同时移动，当其中一个到最后的时候，另一个所在就是
* 三指针，其实就是降级，将三根指针转换为两根 `a+b+c=0; => a + b = -c`
* 两个数组求中位数 



https://chocoluffy.com/2016/12/04/%E6%B5%85%E6%9E%90%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98-two-pointer%E7%9A%84%E8%BF%90%E7%94%A8/